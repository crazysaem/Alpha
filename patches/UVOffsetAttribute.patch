diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
index 9e321de..f3559f5 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
@@ -27,13 +27,7 @@ import com.badlogic.gdx.graphics.g3d.Environment;
 import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Renderable;
 import com.badlogic.gdx.graphics.g3d.Shader;
-import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.IntAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.*;
 import com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap;
 import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
 import com.badlogic.gdx.graphics.g3d.environment.PointLight;
@@ -99,6 +93,7 @@ public class DefaultShader extends BaseShader {
 		public final static Uniform reflectionColor = new Uniform("u_reflectionColor", ColorAttribute.Reflection);
 		public final static Uniform normalTexture = new Uniform("u_normalTexture", TextureAttribute.Normal);
 		public final static Uniform alphaTest = new Uniform("u_alphaTest", FloatAttribute.AlphaTest);
+    public final static Uniform uvOffset = new Uniform("u_uvOffset", UVOffsetAttribute.Type);
 
 		public final static Uniform ambientCube = new Uniform("u_ambientCubemap");
 		public final static Uniform dirLights = new Uniform("u_dirLights");
@@ -451,6 +446,7 @@ public class DefaultShader extends BaseShader {
 	public final int u_reflectionColor;
 	public final int u_normalTexture;
 	public final int u_alphaTest;
+  public final int u_uvOffset;
 	// Lighting uniforms
 	protected final int u_ambientCubemap;
 	protected final int u_environmentCubemap;
@@ -558,6 +554,7 @@ public class DefaultShader extends BaseShader {
 		u_reflectionColor = register(Inputs.reflectionColor, Setters.reflectionColor);
 		u_normalTexture = register(Inputs.normalTexture, Setters.normalTexture);
 		u_alphaTest = register(Inputs.alphaTest);
+    u_uvOffset = register(Inputs.uvOffset);
 
 		u_ambientCubemap = lighting ? register(Inputs.ambientCube, new Setters.ACubemap(config.numDirectionalLights,
 			config.numPointLights)) : -1;
@@ -645,6 +642,8 @@ public class DefaultShader extends BaseShader {
 			prefix += "#define " + FloatAttribute.ShininessAlias + "Flag\n";
 		if ((mask & FloatAttribute.AlphaTest) == FloatAttribute.AlphaTest)
 			prefix += "#define " + FloatAttribute.AlphaTestAlias + "Flag\n";
+    if ((mask & UVOffsetAttribute.Type) == UVOffsetAttribute.Type)
+      prefix += "#define " + UVOffsetAttribute.UVOffsetAlias + "Flag\n";
 		if (renderable.bones != null && config.numBones > 0) prefix += "#define numBones " + config.numBones + "\n";
 		return prefix;
 	}
@@ -726,12 +725,16 @@ public class DefaultShader extends BaseShader {
 				cullFace = ((IntAttribute)attr).value;
 			else if ((t & FloatAttribute.AlphaTest) == FloatAttribute.AlphaTest)
 				set(u_alphaTest, ((FloatAttribute)attr).value);
-			else if ((t & DepthTestAttribute.Type) == DepthTestAttribute.Type) {
-				DepthTestAttribute dta = (DepthTestAttribute)attr;
-				depthFunc = dta.depthFunc;
-				depthRangeNear = dta.depthRangeNear;
-				depthRangeFar = dta.depthRangeFar;
-				depthMask = dta.depthMask;
+			else if ((t & DepthTestAttribute.Type) == DepthTestAttribute.Type)
+      {
+        DepthTestAttribute dta = (DepthTestAttribute) attr;
+        depthFunc = dta.depthFunc;
+        depthRangeNear = dta.depthRangeNear;
+        depthRangeFar = dta.depthRangeFar;
+        depthMask = dta.depthMask;
+      } else if ((t & UVOffsetAttribute.Type) == UVOffsetAttribute.Type) {
+        UVOffsetAttribute uv = (UVOffsetAttribute) attr;
+        set(u_uvOffset, uv.u, uv.v);
 			} else if (!config.ignoreUnimplemented) throw new GdxRuntimeException("Unknown material attribute: " + attr.toString());
 		}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl
index c14953d..f35a362 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl
@@ -29,6 +29,10 @@ attribute vec2 a_texCoord0;
 varying vec2 v_texCoords0;
 #endif // textureFlag
 
+#ifdef UVOffsetFlag
+uniform vec2 u_uvOffset;
+#endif // UVOffsetFlag
+
 #ifdef boneWeight0Flag
 #define boneWeightsFlag
 attribute vec2 a_boneWeight0;
@@ -179,6 +183,11 @@ void main() {
 	#ifdef textureFlag
 		v_texCoords0 = a_texCoord0;
 	#endif // textureFlag
+
+	#ifdef UVOffsetFlag
+  		v_texCoords0.x += u_uvOffset.x;
+  		v_texCoords0.y += u_uvOffset.y;
+  	#endif // UVOffsetFlag
 	
 	#if defined(colorFlag)
 		v_color = a_color;
 .../graphics/g3d/attributes/UVOffsetAttribute.java | 35 ++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/UVOffsetAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/UVOffsetAttribute.java
new file mode 100644
index 0000000..a6cfa10
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/UVOffsetAttribute.java
@@ -0,0 +1,35 @@
+package com.badlogic.gdx.graphics.g3d.attributes;
+
+import com.badlogic.gdx.graphics.g3d.Attribute;
+
+/**
+ * Created by crazysaem on 20.06.2014.
+ */
+public class UVOffsetAttribute extends Attribute
+{
+  public static final String UVOffsetAlias = "UVOffset";
+  public static final long Type = register(UVOffsetAlias);
+
+  public float u;
+  public float v;
+
+  public UVOffsetAttribute(float u, float v)
+  {
+    super(Type);
+
+    this.u = u;
+    this.v = v;
+  }
+
+  @Override
+  public Attribute copy()
+  {
+    return new UVOffsetAttribute(u, v);
+  }
+
+  @Override
+  protected boolean equals(Attribute other)
+  {
+    return ((UVOffsetAttribute)other).u == u && ((UVOffsetAttribute)other).v == v;
+  }
+}
